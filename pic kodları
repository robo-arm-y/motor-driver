//=====================================================
// PIC16F1829 - Faz Kontrollü Triac + AC Akım + Faz Gerilimi + LCD
//
// - 8 MHz iç osilatör (iç)
// - 0 geçiş: Comparator C1 (RA0 = faz, RA1 = nötr)
// - POT: RA2 / AN2 (0..5V) -> 1..9 ms gecikme
// - Akım sensörü: RC2 / AN6 (AC, 2.5V offsetli, I = 2 * (Vdiff + 0.4))
// - Faz sensörü: RA4 / AN3 (tepe ~1.6V => 220V için çarpan 137.5)
// - Triac gate: RC5
// - LCD 4-bit: RS=RC0, E=RC1, D4=RB4, D5=RB5, D6=RB6, D7=RB7
//
// Akım:
//   500 örnek/saniye, 1 saniye boyunca:
//   delta_adc = |adc - 512|
//   V_diff = delta_adc * 5 / 1023
//   V_kalib = V_diff + 0.4
//   I = 2 * V_kalib
//
// Faz:
//   1 saniyedeki max ADC (AN3/RA4):
//   V_faz = max_adc * 5 / 1023
//   V_sebeke = V_faz * 137.5
//=====================================================

#include <16F1829.h>

#device ADC=10                 // 10-bit ADC

//------------- FUSE AYARLARI -------------
#fuses INTRC_IO                // Dahili RC osilatör, RA6/RA7 I/O
#fuses NOWDT, NOBROWNOUT, NOMCLR

#use delay(clock=8000000)      // 8 MHz

//------------- AKIM ÖLÇÜM SABİTLERİ -------------
// 2.5V merkeze denk gelen ADC kodu (5V, 10-bit için ~512)
#define AKIM_OFFSET_ADC      512    

// ADC->Volt dönüşümü: V = adc * (5.0 / 1023.0)
#define AKIM_VREF            5.0
#define AKIM_ADC_FULLSCALE   1023.0

// Akım oranı: I = 2 * (V_diff + 0.4)
#define AKIM_CARPAN          2.0    // I = 2 * V
#define AKIM_V_OFFSET        0.3    // Ölçülen V_diff'e eklenecek ofset (V)

// Akım örnekleme hızı: ~500 örnek/s
#define AKIM_ORNEK_HEDEF     500    // 1 saniyede 500 örnek
#define AKIM_ORNEK_ARALIK_US 2000   // 2 ms'de bir örnek (500 Hz)

// Triac gate pulse süresi (µs)
#define TRIAC_PULSE_US       300

// Faz gerilimi çarpanı (1.6V -> 220V)
#define FAZ_CARPAN           137.5

//=====================================================
//              PIN TANIMLARI
//=====================================================

#define PIN_ZC_FAZ   PIN_A0    // RA0 / AN0 / C1IN+   (0 geçiş faz)
#define PIN_ZC_NOTR  PIN_A1    // RA1 / AN1 / C12IN0- (0 geçiş nötr)
#define PIN_POT      PIN_A2    // RA2 / AN2 - Pot
#define PIN_VFAZ     PIN_A4    // RA4 / AN3 - Faz sensörü
#define PIN_IAKIM    PIN_C2    // RC2 / AN6 - Akım sensörü
#define PIN_TRIAC    PIN_C5    // RC5 - Triac gate

// LCD pinleri
#define LCD_RS   PIN_C0        // RS -> RC0
#define LCD_E    PIN_C1        // E  -> RC1
#define LCD_D4   PIN_B4        // D4 -> RB4
#define LCD_D5   PIN_B5        // D5 -> RB5
#define LCD_D6   PIN_B6        // D6 -> RB6
#define LCD_D7   PIN_B7        // D7 -> RB7
// RW pinini GND'ye bağla (sadece yazma)

//=====================================================
//              COMPARATOR SFR TANIMLARI
//=====================================================
#byte CM1CON0 = getenv("SFR:CM1CON0")
#byte CM1CON1 = getenv("SFR:CM1CON1")

//=====================================================
//              GLOBAL DEĞİŞKENLER
//=====================================================

// 0 geçiş / triac için
int1  c1_prev;                 // Önceki C1OUT durumu
int1  zc_pending = 0;          // Sıfır geçiş sonrası tetikleme bekleniyor mu?
int1  gate_active = 0;         // Gate darbesi şu an aktif mi?

unsigned int16 zc_time_us;     // Sıfır geçiş anındaki Timer1 değeri (µs)
unsigned int16 gate_start_us;  // Gate HIGH başladığı anın Timer1 değeri
unsigned int16 fire_delay_us;  // Pot'a göre hesaplanan gecikme (µs)

// Akım ölçümü için
unsigned int32 akim_toplam_diff = 0;  // |ADC - offset| toplamı
unsigned int16 akim_ornek_sayisi = 0; // Toplanan örnek sayısı
unsigned int16 son_ornek_zaman_us = 0;

// Faz ölçümü için
unsigned int16 faz_max_adc = 0;       // 1 saniyedeki max faz ADC değeri

//=====================================================
//              LCD YARDIMCI FONKSİYONLAR
//=====================================================
void lcd_pulse_enable() {
   output_high(LCD_E);
   delay_us(2);
   output_low(LCD_E);
   delay_us(2);
}

void lcd_send_nibble(int8 nib) {
   output_bit(LCD_D4, (nib >> 0) & 1);
   output_bit(LCD_D5, (nib >> 1) & 1);
   output_bit(LCD_D6, (nib >> 2) & 1);
   output_bit(LCD_D7, (nib >> 3) & 1);
   lcd_pulse_enable();
}

void lcd_send_byte(int1 rs, int8 data) {
   output_bit(LCD_RS, rs);               // rs = 0 -> komut, 1 -> data
   lcd_send_nibble((data >> 4) & 0x0F);  // üst 4 bit
   lcd_send_nibble(data & 0x0F);         // alt 4 bit
   delay_us(50);
}

void lcd_command(int8 cmd) {
   lcd_send_byte(0, cmd);
}

void lcd_write_char(char c) {
   lcd_send_byte(1, c);
}

void lcd_gotoxy(int x, int y) {
   int8 addr;
   if(y == 1)
      addr = 0x00 + (x - 1);   // 1. satır
   else
      addr = 0x40 + (x - 1);   // 2. satır
   lcd_command(0x80 | addr);
}

void lcd_putc(char c) {
   switch(c) {
      case '\f':          // Ekranı temizle
         lcd_command(0x01);
         delay_ms(2);
         break;

      case '\n':          // 2. satıra geç
         lcd_gotoxy(1, 2);
         break;

      case '\r':          // Satır başı (yok say)
         break;

      default:            // Normal karakter
         lcd_write_char(c);
         break;
   }
}

void lcd_init_custom() {
   output_low(LCD_RS);
   output_low(LCD_E);
   output_low(LCD_D4);
   output_low(LCD_D5);
   output_low(LCD_D6);
   output_low(LCD_D7);

   delay_ms(20);      // LCD açılış süresi

   // 8-bit moddan 4-bit moda geçiş
   lcd_send_nibble(0x03);
   delay_ms(5);
   lcd_send_nibble(0x03);
   delay_us(150);
   lcd_send_nibble(0x03);
   delay_us(150);
   lcd_send_nibble(0x02);   // 4-bit mod

   // Fonksiyon set: 4-bit, 2 satır, 5x8 font
   lcd_command(0x28);
   // Display ON, imleç kapalı
   lcd_command(0x0C);
   // Entry mode: imleç sağa
   lcd_command(0x06);
   // Ekranı temizle
   lcd_command(0x01);
   delay_ms(2);
}

//=====================================================
//                      main()
//=====================================================
void main() {

   // 8 MHz iç osilatör
   setup_oscillator(OSC_8MHZ);

   //-----------------------------------------
   // ADC: AN2 (POT), AN3 (faz), AN6 (akım) analog
   //-----------------------------------------
   setup_adc_ports(sAN2 | sAN3 | sAN6, VSS_VDD);   // RA2, RA4, RC2 analog
   setup_adc(ADC_CLOCK_INTERNAL);

   //-----------------------------------------
   // Timer1:
   // Fosc=8 MHz -> Fosc/4=2 MHz -> 0.5 µs
   // Prescaler 2 -> 1 µs/tick
   //-----------------------------------------
   setup_timer_1(T1_INTERNAL | T1_DIV_BY_2);
   set_timer1(0);

   //-----------------------------------------
   // Comparator C1: RA0(+) / RA1(-)
   //-----------------------------------------
   CM1CON1 = 0x00;        // + giriş C1IN+ (RA0), - giriş C12IN0- (RA1)
   CM1CON0 = 0b10000000;  // C1ON=1, C1OUT bit6 geçerli

   //-----------------------------------------
   // Triac çıkışı LOW başlasın
   //-----------------------------------------
   output_low(PIN_TRIAC);

   //-----------------------------------------
   // LCD'yi başlat
   //-----------------------------------------
   lcd_init_custom();
   lcd_putc('\f');
   lcd_gotoxy(1,1);
   printf(lcd_putc, "AKIM=0.0A    ");
   lcd_gotoxy(1,2);
   printf(lcd_putc, "FAZ GER=---V ");

   //-----------------------------------------
   // İlk comparator çıktısını oku
   //-----------------------------------------
   c1_prev = bit_test(CM1CON0, 6);   // C1OUT

   // Akım örnekleme zamanı başlangıcı
   son_ornek_zaman_us = get_timer1();

   // Faz max adc başlangıç
   faz_max_adc = 0;

   while(TRUE)
   {
      //------------------------------------------------
      // 1) SIFIR GEÇİŞİ SÜREKLİ İZLE (EN ÖNCELİK)
      //------------------------------------------------
      {
         int1 c1_now = bit_test(CM1CON0, 6);

         if(c1_now != c1_prev) {
            // C1OUT değişti -> sıfır geçiş oldu
            c1_prev = c1_now;

            // Sıfır geçiş anını kaydet
            zc_time_us = get_timer1();
            zc_pending = 1;
            gate_active = 0;  // Yeni yarım periyot, eski gate işi bitti say

            // POT oku -> gecikme hesapla (1..9 ms => 1000..9000 µs)
            unsigned int16 pot_adc;
            unsigned int32 temp32;

            set_adc_channel(2);       // AN2 (RA2)
            delay_us(5);
            pot_adc = read_adc();     // 0..1023

            // 0..1023 -> 1000..9000 µs (8 ms aralık)
            temp32 = (unsigned int32)pot_adc * 8000;
            fire_delay_us = 1000 + (unsigned int16)(temp32 / 1023);

            // Güvenlik clamp
            if(fire_delay_us < 1000) fire_delay_us = 1000;
            if(fire_delay_us > 9000) fire_delay_us = 9000;
         }
      }

      //------------------------------------------------
      // 2) SIFIR GEÇİŞTEN SONRA GECİKME DOLUNCA GATE VER
      //------------------------------------------------
      if(zc_pending && !gate_active) {
         unsigned int16 now_us = get_timer1();
         unsigned int16 elapsed_us = now_us - zc_time_us;  // wrap güvenli

         if(elapsed_us >= fire_delay_us) {
            // Triac gate tetikle
            output_high(PIN_TRIAC);
            gate_start_us = now_us;
            gate_active = 1;
         }
      }

      //------------------------------------------------
      // 3) GATE PULSE SÜRESİNİ KONTROL ET, SÜRE DOLUNCA KAPAT
      //------------------------------------------------
      if(gate_active) {
         unsigned int16 now2_us = get_timer1();
         unsigned int16 elapsed2_us = now2_us - gate_start_us;

         if(elapsed2_us >= TRIAC_PULSE_US) {
            output_low(PIN_TRIAC);
            gate_active = 0;
            zc_pending = 0;   // Bu yarım periyot işi bitti
         }
      }

      //------------------------------------------------
      // 4) AKIM + FAZ ÖLÇÜMÜ (500 ÖRNEK/S) - TRIAC'TAN BAĞIMSIZ
      //------------------------------------------------
      {
         unsigned int16 now_samp_us = get_timer1();
         unsigned int16 elapsed_samp = now_samp_us - son_ornek_zaman_us;

         if(elapsed_samp >= AKIM_ORNEK_ARALIK_US) {
            unsigned int16 akim_adc, delta_adc, faz_adc;
            unsigned int16 ort_adc_diff;
            float V_diff, V_kalib, I_amp;
            float faz_volt, faz_gerilim;
            int16 faz_int;

            son_ornek_zaman_us = now_samp_us;

            // --- Akım okuma ---
            set_adc_channel(6);          // AN6 (RC2)
            delay_us(5);
            akim_adc = read_adc();       // 0..1023

            if(akim_adc > AKIM_OFFSET_ADC)
               delta_adc = akim_adc - AKIM_OFFSET_ADC;
            else
               delta_adc = AKIM_OFFSET_ADC - akim_adc;

            akim_toplam_diff += delta_adc;
            akim_ornek_sayisi++;

            // --- Faz okuma (max değeri tut) ---
            set_adc_channel(3);          // AN3 (RA4)
            delay_us(5);
            faz_adc = read_adc();
            if(faz_adc > faz_max_adc)
               faz_max_adc = faz_adc;

            // 1 saniyelik pencere doldu mu?
            if(akim_ornek_sayisi >= AKIM_ORNEK_HEDEF) {

               // Ortalama ADC farkı (akım)
               ort_adc_diff = (unsigned int16)(akim_toplam_diff / akim_ornek_sayisi);

               // V_diff = (|ADC-512| ort) -> Volt
               V_diff = ((float)ort_adc_diff * AKIM_VREF) / AKIM_ADC_FULLSCALE;

               // Kalibrasyon: 0.4V offset ekle
               V_kalib = V_diff + AKIM_V_OFFSET;
               if(V_kalib < 0.0) V_kalib = 0.0;  // teorik güvenlik, zaten hep pozitif olacak

               // I = 2 * V_kalib
               I_amp = V_kalib * AKIM_CARPAN;

               // Faz gerilimi hesabı (max ADC üzerinden)
               faz_volt    = ((float)faz_max_adc * 5.0) / 1023.0;  // sensör çıkışı (V)
               faz_gerilim = faz_volt * FAZ_CARPAN;                // 1.6V -> 220V
               faz_int     = (int16)(faz_gerilim + 0.5);

               // LCD 1. satır: Akım (küsuratlı)
               lcd_gotoxy(1,1);
               printf(lcd_putc, "AKIM=%4.1fA  ", I_amp);

               // LCD 2. satır: Faz gerilimi
               lcd_gotoxy(1,2);
               printf(lcd_putc, "FAZ GER=%3luV", (unsigned int16)faz_int);

               // Sayaçları sıfırla (yeni pencere için)
               akim_toplam_diff = 0;
               akim_ornek_sayisi = 0;
               faz_max_adc = 0;
            }
         }
      }

      //------------------------------------------------
      // Döngüde ekstra delay yok -> 0 geçiş ve triac her zaman öncelikli
      //------------------------------------------------
   }
}
